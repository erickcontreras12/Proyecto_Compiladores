package Classes;

import java_cup.runtime.Symbol;
import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;
import java_cup.runtime.virtual_parse_stack;
import java.lang.reflect.Field;

parser code
{:
    private Symbol s;
    private String errors_list = ""; 

    public String getErrorString(){
        return errors_list;
    }

    public String symbl_name_from_id(int id){
	Field[] fields = getSymbolContainer().getFields();
	for(Field f : fields){
		try {
                    if (f.getInt(null)==id)
			  return f.getName();
		} catch (IllegalArgumentException e) {
			//e.printStackTrace();
		} catch (IllegalAccessException ex) { 
                        //e.printStackTrace();
                } 
	  }
	return "invalid symbol id";
    }

    public void syntax_error(Symbol s){
        this.s=s; 
        List<Integer> ids = expected_token_ids();
	LinkedList<String> list = new LinkedList<String>();
	for (Integer expected : ids){
            list.add(symbl_name_from_id(expected));
            list.add("\n");
        }
        errors_list += "Line: " + (s.right + 1) + " and column: " + (s.left + 1) + ", '" + s.value +"', recuperable error: missing symbol " + list + "\n";
        System.out.println("Error R de sintaxis: "+ s.value +" Columna "+(s.left+1)+" linea "+(s.right+1)+"tokens esperados"+list+"\n\n" );  
    }

    public List<Integer> expected_token_ids() {
        List<Integer> ret = new LinkedList<Integer>();
	int parse_state = ((Symbol)stack.peek()).parse_state ;
	short[] row = action_tab[parse_state];
	for (int i = 0; i<row.length; i+=2){
            if (row[i]==-1) continue;
            if (!validate_expected_symbol(row[i])) continue;
            ret.add(new Integer(row[i]));
	}
	return ret;
    }

    protected static final int _error_sync_size(){
        return 1;
    }

    private boolean validate_expected_symbol(int id){
	short lhs,rhs_size;
	int act;
	try {
            virtual_parse_stack vstack = new virtual_parse_stack(stack);
            /* parse until we fail or get past the lookahead input */
            for (;;)
            {
                /* look up the action from the current state (on top of stack) */
                act = get_action(vstack.top(), id);
                
                /* if its an error, we fail */
		if (act == 0) return false;

        	/* > 0 encodes a shift */
		if (act > 0){
                    /* push the new state on the stack */
                    vstack.push(act-1);

        	    /* advance simulated input, if we run off the end, we are done */
                    if (!advance_lookahead()) return true;
                }
                /* < 0 encodes a reduce */
		else
		{
                    /* if this is a reduce with the start production we are done */
                    if ((-act)-1 == start_production())  return true;

                    /* get the lhs Symbol and the rhs size */
                    lhs = production_tab[(-act)-1][0];
                    rhs_size = production_tab[(-act)-1][1];
                    /* pop handle off the stack */
                    for (int i = 0; i < rhs_size; i++) vstack.pop();
                    vstack.push(get_reduce(vstack.top(), lhs));
                }
            }
	} catch (Exception e) {
            e.printStackTrace();
	}
	return true;
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        List<Integer> ids = new LinkedList<>();
        ids=expected_token_ids();
	LinkedList<String> list = new LinkedList<String>();
	for (Integer expected : ids){
            list.add(symbl_name_from_id(expected));
            list.add("\n");
        }

        errors_list += "Line: " + (s.right + 1) + " and column: " + (s.left + 1) + ", '" + s.value +"', Non recuperable error: missing symbol " + list + "\n";
        System.out.println("Error NR de sintaxis: "+ s.value +" Columna "+(s.left+1)+" linea "+(s.right+1)+"tokens esperados"+list+"\n\n" );   
    }

:};

terminal BIT, INT, FLOAT, STRING, PALABRA_RESERVADA, ID, ERROR, ERROR_F, MAS, MENOS, MULT, DIV, RES, MENOR, MENOR_O_IGUAL, MAYOR, MAYOR_O_IGUAL, IGUAL, IGUAL_A, DIFERENTE, 
    AND, OR, EXCLAMACION, PUNTO_COMA, COMA, PUNTO, CORCHETE_ABIERTO, CORCHETE_CERRADO, PARENTESIS_ABIERTO, PARENTESIS_CERRADO, LLAVE_ABIERTO, LLAVE_CERRADO, CORCHETES, PARENTESIS,
    LLAVES, ARROBA, NUMERAL, DOBLE_NUMERAL, COMENTARIO_M, INSERT, DELETE, UPDATE, SELECT, CREATE, ALTER, TRUNCATE, DROP, INTO, VALUES, DEFAULT, DATABASE, INDEX, USER,
    TABLE, VIEW, CURRENT, NAME, MODIFY, ON, CONSTRAINT, USABLE, REBUILD, DISABLE, UNUSABLE, ALL, WITH, DEFAULT_SCHEMA, NULL, LOGIN, PASSWORD, ADD, COLUMN, UNIQUE, FLOAT_P,
    CHAR, VARCHAR, DECIMAL, NUMERIC, IMAGE, VARBINARY, TEXT, DATE, DATETIME, DATETIME2, SMALLDATETIME, TIME, DATETIMEOFFSET, TIMESTAMP, MONEY, REAL, BIT_P, INT_P, BETWEEN,
    GO, LIKE, NOT, PRIMARY, KEY, IDENTITY, REFERENCES, AND_O, OR_O, FOREIGN, CHECK, IF, EXISTS, TOP, PERCENT, FROM, WHERE, SET, AS, DISTINCT, LEFT, RIGHT, GROUP, ORDER, HAVING,
    JOIN, OUTER, INNER, FULL, DESC, ASC, AVG, SUM, COUNT, MAX, MIN, CLUSTERED, NONCLUSTERED, FOR, INCLUDE, BY, NAMES, FILE, FILES, FILENAME, SIZE, MAXSIZE, KB, MB, GB, TB,
    FILEGROWTH, PROCEDURE, FUNCTION, RETURN, RETURNS, EXEC, EXECUTE, EXECUTE_AS_CLAUSE, USE, SCHEMA, BEGIN, END, TRAN, TRANSACTION, COMMIT, ROLLBACK, SAVE,
    DECLARE, VARYING, CURSOR, TO, RECOMPILE, ENCRYPTION, SELF, OWNER, CALLER, OUT, OUTPUT, READONLY, REPLICATION, OFF, SCHEMABINDING, INLINE, CALLED, MARK, STATIC,
    FORWARD_ONLY, KEYSET, FAST_FORWARD, DYNAMIC, READ_ONLY, SCROLL_LOCKS, SCROLL, OPTIMISTIC, TYPE_WARNING, INPUT, LOCAL, GLOBAL, COLLATE , INMEDIATE;

non terminal Start, general1, general, Stmt, EndStmt, StmtDML, StmtDDL, StmtTCL, StmtTSQL, select, insert, update, delete, create, alter, truncate, drop, cursor, obj_n, obj_n1, obj_n2, tipo_dato,
    aritmetica, aritmetica1, parte, parte1, parte2, list_table, list_table1, opcion_select, seleccion, expresion, columna, columna1, columna2, funciones, valor, puede, alias_columna, origen, 
    origen1, alias_tabla, opcion_alias, joins, tipo_join, tipo_join1, joins1, condicionales, condicionales1, otra_condicion, operadores_logicos, operadores, agrupado, agrupado1, teniendo, teniendo1,
    teniendo2, orden, orden1, tipo_orden, num 
    ;

start with Start;

Start ::= general1 ;
general1 ::= general | /*epsilon*/ ;
general ::= Stmt EndStmt general1 | error EndStmt general1;
Stmt ::= StmtDML | StmtDDL | StmtTCL | StmtTSQL ;
StmtDML ::= select | insert | update | delete ;
StmtDDL ::= create | alter | truncate | drop ;
StmtTSQL ::= cursor ;
EndStmt ::= GO | PUNTO_COMA | PUNTO_COMA GO | GO PUNTO_COMA | PUNTO_COMA GO PUNTO_COMA  ;

num ::= INT | BIT ;

obj_n ::= ID obj_n1 ;
obj_n1 ::= PUNTO ID obj_n2 | /*epsilon*/ ;
obj_n2 ::= PUNTO ID | /*epsilon*/ ;

tipo_dato ::= STRING | num | FLOAT ;

aritmetica ::= parte aritmetica1 ; 
aritmetica1 ::= MAS parte | MENOS parte | /*epsilon*/ ;
parte ::= parte2 parte1 ;
parte1 ::= MULT parte2 | DIV parte2 | /*epsilon*/ ;
parte2 ::= PARENTESIS_ABIERTO aritmetica PARENTESIS_CERRADO | INT | FLOAT | obj_n ;

truncate ::= TRUNCATE TABLE list_table ;
list_table ::= obj_n list_table1 ;
list_table ::= COMA list_table | /*epsilon*/ ;


/*select */
select ::=  SELECT opcion_select FROM origen joins condicionales agrupado teniendo orden ;

opcion_select ::=  seleccion columna ;
seleccion ::=  DISTINCT | ALL | TOP expresion |  /*epsilon*/ ;
expresion ::=  num | PARENTESIS_ABIERTO num PARENTESIS_CERRADO ;
columna ::=  columna1 alias_columna columna2 ;
columna1 ::=  funciones | aritmetica | obj_n IGUAL aritmetica | MULT ;
columna2 ::=  COMA columna |  /*epsilon*/  ;

funciones ::=  SUM PARENTESIS_ABIERTO valor PARENTESIS_CERRADO | AVG PARENTESIS_ABIERTO valor PARENTESIS_CERRADO | 
            COUNT PARENTESIS_ABIERTO valor PARENTESIS_CERRADO | MIN PARENTESIS_ABIERTO valor PARENTESIS_CERRADO |
             MAX PARENTESIS_ABIERTO valor PARENTESIS_CERRADO ;
valor ::=  num | MULT | puede obj_n ;
puede ::=  DISTINCT |  /*epsilon*/  ;
alias_columna ::=  AS opcion_alias |  /*epsilon*/ ;


origen ::=  obj_n alias_tabla origen1 ;
origen1 ::=  COMA origen |  /*epsilon*/ ; 
alias_tabla ::=  AS opcion_alias | ID |  /*epsilon*/  ;
opcion_alias ::=  STRING | ID ;

joins ::=  tipo_join JOIN obj_n alias_tabla ON obj_n IGUAL obj_n joins1 | /*epsilon*/ ;
tipo_join ::=  INNER | LEFT tipo_join1 | RIGHT tipo_join1 | FULL tipo_join1 |  /*epsilon*/ ;
tipo_join1 ::=  OUTER |  /*epsilon*/  ;
joins1 ::=  joins ;

condicionales ::=  WHERE ID operadores tipo_dato condicionales1 | /*epsilon*/ ;
condicionales1 ::=  operadores_logicos otra_condicion |  /*epsilon*/  ;
otra_condicion ::=  ID operadores tipo_dato condicionales1 ;
operadores_logicos ::=  AND | OR | AND_O | OR_O ;
operadores ::=  MENOR | MAYOR | MENOR_O_IGUAL | MAYOR_O_IGUAL | DIFERENTE | IGUAL_A | LIKE | BETWEEN num AND num ;

agrupado ::=  GROUP BY obj_n agrupado1 |  /*epsilon*/ ;
agrupado1 ::=  COMA obj_n agrupado1 |  /*epsilon*/ ;

teniendo ::=  HAVING teniendo1 |  /*epsilon*/ ;
teniendo1 ::=  funciones operadores tipo_dato teniendo2 ;
teniendo2 ::=  operadores_logicos teniendo1 |  /*epsilon*/ ; 

orden ::=  ORDER BY obj_n tipo_orden orden1 |  /*epsilon*/   ;
orden1 ::=  COMA obj_n orden1 |  /*epsilon*/ ;
tipo_orden ::=  ASC | DESC |  /*epsilon*/ ;